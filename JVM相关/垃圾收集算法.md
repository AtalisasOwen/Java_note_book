# 垃圾收集算法的发展（见深入理解JVM ==P69）

## 1.标记-清除算法

* #### 首先标记出需要回收的对象，在标记完成后统一回收。
* #### 有效率问题（标记和清除的效率都不高）
* #### 有空间问题（内存中对象分布不均）

## 2.复制算法

* #### 将可用内存划分为大小相等的两块，每次只使用一块。当一块用完了，就将还存活的对象复制到另外一半上面。然后对已使用的内存空间进行清理。
* ### 对此的扩展：

  * #### 分为一块80%的Eden空间和两块10%的Survivor空间
  * #### 每次使用Eden和一块Survivor。
  * #### 当回收时，将Eden和Survivor中还存活的对象复制到另一块Survivor上面。

## 3.标记-整理算法

* 首先标记出所有可回收的对象

* 将不可回收对象向内存首部移动

* 然后清理掉 ，除首部存活对象之外的内存



## 垃圾收集器

### 新生代：Serial，ParNew，Parallel Scavenge

### 老生代：CMS，Serial Old，Parallel Old

* ### Serial收集器：采用复制算法，它在进行垃圾收集时，会停掉所有工作线程。Client默认
* ### ParNew收集器：采用复制算法，多线程收集版本的Serial，和Serial基本一致。Server首选
* ### Parallel Scavenge收集器：也是使用复制算法的多线程收集器。吞吐量优先的收集器，使得垃圾收集的占CPU运行比最小
* ### Serial Old收集器：使用标记-整理算法，它在进行垃圾收集时，会停掉所有工作线程。Client默认
* ### Parallel Old收集器：Parallel Scavenge收集器的老生代版本，多线程+标记-整理算法，如果新生代使用了Parallel Scavenge，可以使用Parallel Old来代替Serial Old来改善性能
* ### CMS收集器（重点）：



