# 类加载器

* ### 类加载的时机：加载=&gt;验证=&gt;准备=&gt;解析=&gt;初始化=&gt;使用=&gt;卸载
* ### 有5种情况必须马上进行类的初始化：

  * ### 遇到new、getstatic、putstatic、invokestatic这4条字节码
  * ### 使用reflect包，进行反射调用的时候
  * ### 当初始化一个类的时候，发现其父类还没有被加载
  * ### 当使用JDK1.7的动态语言支持
* ### 在类初始化阶段会将static final String的变量提升到掉用类的常量池中

```java
public class ConstClass{
    static {
        System.out.print("ConstClass init");
    }
    public static final String HELLOWORLD = "hello world";
}

public class NotInitialization{
    public static void main(String...args){
        System.out.println(ConstClass.HELLOWORLD);
    }
}

//只会输出hello world
//没有初始化语句
//转化为NotInitialization对自身常量池的引用
//这两个类在编译后就没有任何联系了
```

* ### 子类继承父类并在子类中访问父类，会初始化父类，而不初始化子类

```java
public class SuperClass{
    static{
        System.out.println("SuperClass init!");
    }
    public static int value = 123;
}

public class SubClass extends SuperClass{
    static{
        System.out.println("SubClass init");
    }
}

==>
public class NotInitialzation{
    public static void main(String...args){
        System.out.println(Sunclass.value);
    }
}
//输出SuperClass init!
//因为对于静态字段，只有定义这个字段的类才会被初始化

==>
public class NotInitialzation{
    public static void main(String...args){
        SuperClass[] src = new SuperClass[10];
    }
}
//无输出
//不会触发SuperClass的初始化阶段
//会触发[L SuperClass的初始化阶段，这是一个虚拟机创建的一维数组类

```



