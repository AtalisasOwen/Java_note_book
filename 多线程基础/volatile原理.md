# volatile原理

* ### volatile变量提供可见性，但不保证原子性。要满足以下条件才应该使用：1.运算结果不依赖当前值或者只有一个线程参与修改（i++不行）2.变量不需要与其他状态变量共同参与不变约束。如在while\(!asleep\){...}, asleep变量为volatile，保证能通知循环的结束。
* ### volatile强制线程从公共堆栈（内存）中读取值，而不是从私有工作堆栈（内存）
* ### volatile可以禁止指令重排序优化
* ### 观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令。lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：

  #### 1）它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；

  #### 2）它会强制将对缓存的修改操作立即写入主存；

  #### 3）如果是写操作，它会导致其他CPU中对应的缓存行无效。



